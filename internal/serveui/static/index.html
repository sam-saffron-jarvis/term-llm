<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chat</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%230d1117'/%3E%3Cpath d='M17 14h30v6H24v26h16v-9H30v-6h17v21H17z' fill='%2358a6ff'/%3E%3C/svg%3E">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css" media="(prefers-color-scheme: light)">
  <style>
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --surface-2: #21262d;
      --border: #30363d;
      --text: #e6edf3;
      --text-muted: #8b949e;
      --accent: #58a6ff;
      --accent-green: #3fb950;
      --accent-amber: #d29922;
      --danger: #f85149;
      --backdrop: rgba(1, 4, 9, 0.55);
      --overlay: rgba(1, 4, 9, 0.72);
      --error-text: #ffd5d4;
      --btn-accent-text: #dceeff;
      --stop-btn-text: #ffd4d2;
      --spinner-ring: rgba(220, 238, 255, 0.45);
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #ffffff;
        --surface: #f6f8fa;
        --surface-2: #eaeef2;
        --border: #d0d7de;
        --text: #1f2328;
        --text-muted: #656d76;
        --accent: #0969da;
        --accent-green: #1a7f37;
        --accent-amber: #9a6700;
        --danger: #d1242f;
        --backdrop: rgba(175, 184, 193, 0.5);
        --overlay: rgba(175, 184, 193, 0.7);
        --error-text: #82071e;
        --btn-accent-text: #ffffff;
        --stop-btn-text: #82071e;
        --spinner-ring: rgba(255, 255, 255, 0.45);
      }
    }

    * {
      box-sizing: border-box;
      scrollbar-width: thin;
      scrollbar-color: var(--surface-2) transparent;
    }

    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--surface-2);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--border);
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      min-height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    body {
      overflow: hidden;
    }

    button,
    input,
    textarea,
    select {
      font: inherit;
      color: inherit;
    }

    .app {
      display: grid;
      grid-template-columns: 260px minmax(0, 1fr);
      height: 100vh;
      width: 100%;
      background: var(--bg);
    }

    .sidebar {
      border-right: 1px solid var(--border);
      background: var(--surface);
      display: flex;
      flex-direction: column;
      min-height: 0;
      z-index: 20;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.85rem 0.8rem;
      border-bottom: 1px solid var(--border);
      min-height: 58px;
    }

    .brand {
      display: inline-flex;
      align-items: center;
      gap: 0.55rem;
      font-size: 0.95rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      min-width: 0;
    }

    .icon-btn {
      border: 1px solid var(--border);
      background: var(--surface-2);
      color: var(--text-muted);
      border-radius: 8px;
      width: 34px;
      height: 34px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: border-color 0.15s ease, color 0.15s ease, background 0.15s ease;
      flex-shrink: 0;
    }

    .icon-btn:hover {
      border-color: var(--accent);
      color: var(--text);
    }

    .icon-btn:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .sidebar-close {
      display: none;
    }

    .sidebar-content {
      min-height: 0;
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .new-chat-wrap {
      padding: 0.75rem;
      border-bottom: 1px solid var(--border);
    }

    .new-chat-btn {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--surface-2);
      color: var(--text);
      padding: 0.6rem 0.75rem;
      text-align: left;
      cursor: pointer;
      font-weight: 600;
      transition: border-color 0.15s ease, background 0.15s ease;
    }

    .new-chat-btn:hover {
      border-color: var(--accent);
      background: color-mix(in srgb, var(--surface-2) 78%, var(--accent) 22%);
    }

    .session-groups {
      overflow-y: auto;
      min-height: 0;
      padding: 0.45rem 0;
    }

    .session-group {
      margin-bottom: 0.25rem;
    }

    .session-group h3 {
      margin: 0;
      padding: 0.5rem 0.75rem 0.35rem;
      font-size: 0.72rem;
      font-weight: 700;
      color: var(--text-muted);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .session-btn {
      width: 100%;
      border: 0;
      background: transparent;
      color: inherit;
      text-align: left;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      border-left: 2px solid transparent;
      display: flex;
      flex-direction: column;
      gap: 0.18rem;
      transition: background 0.15s ease, border-color 0.15s ease;
    }

    .session-btn:hover {
      background: color-mix(in srgb, var(--surface) 80%, white 20%);
    }

    .session-btn.active {
      border-left-color: var(--accent);
      background: color-mix(in srgb, var(--surface) 65%, var(--accent) 35%);
    }

    .session-title {
      font-size: 0.9rem;
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .session-meta {
      font-size: 0.77rem;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .main {
      min-width: 0;
      min-height: 0;
      display: flex;
      flex-direction: column;
      background: var(--bg);
      position: relative;
    }

    .main-header {
      min-height: 58px;
      border-bottom: 1px solid var(--border);
      background: var(--surface);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      flex-wrap: wrap;
    }

    .header-left {
      display: inline-flex;
      align-items: center;
      gap: 0.6rem;
      min-width: 0;
    }

    .mobile-menu {
      display: none;
    }

    .header-title {
      margin: 0;
      font-size: 1rem;
      line-height: 1.2;
      font-weight: 650;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: min(48vw, 520px);
    }

    .connection-state {
      color: var(--text-muted);
      font-size: 0.78rem;
      white-space: nowrap;
    }

    .connection-state.ok {
      color: var(--accent-green);
    }

    .connection-state.bad {
      color: var(--danger);
    }

    .header-right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .model-select {
      border: 1px solid var(--border);
      background: var(--surface-2);
      border-radius: 8px;
      padding: 0.35rem 0.6rem;
      max-width: 320px;
      min-width: 160px;
    }

    .chat-scroll {
      min-height: 0;
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    .messages {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
    }

    .empty-state {
      margin: 2rem auto;
      text-align: center;
      color: var(--text-muted);
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 1rem;
      background: color-mix(in srgb, var(--surface) 88%, transparent);
      max-width: 500px;
    }

    .message {
      width: min(100%, 820px);
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }

    .message.user {
      align-self: flex-end;
      width: min(78%, 820px);
    }

    .message.assistant,
    .message.tool,
    .message.error {
      align-self: flex-start;
    }

    .message-body {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0.75rem 0.9rem;
      line-height: 1.5;
      font-size: 0.96rem;
      overflow-x: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .message.user .message-body {
      background: color-mix(in srgb, var(--accent) 20%, var(--surface) 80%);
      border-color: color-mix(in srgb, var(--accent) 45%, var(--border) 55%);
      color: var(--text);
      white-space: pre-wrap;
    }

    .message.assistant .message-body {
      background: var(--surface-2);
    }

    .message.error .message-body {
      background: color-mix(in srgb, var(--danger) 14%, var(--surface) 86%);
      border-color: color-mix(in srgb, var(--danger) 55%, var(--border) 45%);
      color: var(--error-text);
    }

    .markdown-body {
      white-space: normal;
    }

    .markdown-body h1,
    .markdown-body h2,
    .markdown-body h3,
    .markdown-body h4,
    .markdown-body h5,
    .markdown-body h6 {
      margin: 0.4em 0 0.3em;
      line-height: 1.25;
    }

    .markdown-body p {
      margin: 0.45em 0;
    }

    .markdown-body ul,
    .markdown-body ol {
      margin: 0.45em 0 0.55em;
      padding-left: 1.3rem;
    }

    .markdown-body blockquote {
      margin: 0.7em 0;
      padding: 0.15em 0.8em;
      border-left: 3px solid var(--accent);
      color: var(--text-muted);
      background: color-mix(in srgb, var(--surface) 70%, var(--accent) 30%);
      border-radius: 4px;
    }

    .markdown-body pre {
      margin: 0.6em 0;
      padding: 0;
      border-radius: 8px;
      overflow: auto;
      border: 1px solid var(--border);
    }

    .markdown-body pre code {
      display: block;
      padding: 0.85rem;
      line-height: 1.45;
      font-size: 0.87rem;
    }

    .markdown-body :not(pre) > code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: color-mix(in srgb, var(--surface) 65%, white 35%);
      border: 1px solid var(--border);
      padding: 0.11rem 0.35rem;
      border-radius: 6px;
      font-size: 0.88em;
    }

    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 0.6rem 0;
      font-size: 0.9rem;
    }

    .markdown-body th,
    .markdown-body td {
      border: 1px solid var(--border);
      padding: 0.35rem 0.5rem;
      text-align: left;
      vertical-align: top;
    }

    .markdown-body th {
      background: color-mix(in srgb, var(--surface-2) 65%, black 35%);
    }

    .markdown-body a {
      color: var(--accent);
      text-decoration: underline;
    }

    .message-meta {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      color: var(--text-muted);
      font-size: 0.74rem;
      padding: 0 0.2rem;
      align-self: flex-end;
    }

    .message.assistant .message-meta,
    .message.tool .message-meta,
    .message.error .message-meta {
      align-self: flex-start;
    }

    .usage-line {
      margin-top: -0.1rem;
      font-size: 0.76rem;
      color: var(--text-muted);
      padding: 0 0.2rem;
    }

    .tool-card {
      border: 1px solid color-mix(in srgb, var(--accent-amber) 46%, var(--border) 54%);
      border-radius: 12px;
      background: color-mix(in srgb, var(--accent-amber) 10%, var(--surface-2) 90%);
      overflow: hidden;
    }

    .tool-toggle {
      width: 100%;
      border: 0;
      background: transparent;
      color: inherit;
      padding: 0.65rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      cursor: pointer;
      text-align: left;
      font-size: 0.92rem;
    }

    .tool-toggle:hover {
      background: color-mix(in srgb, var(--surface-2) 80%, var(--accent-amber) 20%);
    }

    .tool-arrow {
      transition: transform 0.14s ease;
      color: var(--text-muted);
      width: 1rem;
      text-align: center;
      flex-shrink: 0;
    }

    .tool-toggle[aria-expanded="true"] .tool-arrow {
      transform: rotate(90deg);
      color: var(--text);
    }

    .tool-name {
      font-weight: 600;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tool-status {
      margin-left: auto;
      color: var(--text-muted);
      font-size: 0.78rem;
      flex-shrink: 0;
    }

    .tool-details {
      border-top: 1px solid var(--border);
      padding: 0.58rem 0.75rem 0.72rem;
      display: none;
    }

    .tool-details.open {
      display: block;
    }

    .tool-details-label {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-bottom: 0.3rem;
    }

    .tool-details pre {
      margin: 0;
      padding: 0.65rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--surface) 85%, black 15%);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 0.83rem;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .tool-group-card {
      border: 1px solid color-mix(in srgb, var(--accent-amber) 46%, var(--border) 54%);
      border-radius: 12px;
      background: color-mix(in srgb, var(--accent-amber) 10%, var(--surface-2) 90%);
      overflow: hidden;
    }

    .tool-group-toggle {
      width: 100%;
      border: 0;
      background: transparent;
      color: inherit;
      padding: 0.65rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      cursor: pointer;
      text-align: left;
      font-size: 0.92rem;
    }

    .tool-group-toggle:hover {
      background: color-mix(in srgb, var(--surface-2) 80%, var(--accent-amber) 20%);
    }

    .tool-group-toggle[aria-expanded="true"] .tool-arrow {
      transform: rotate(90deg);
      color: var(--text);
    }

    .tool-group-summary {
      font-weight: 600;
      min-width: 0;
    }

    .tool-group-details {
      border-top: 1px solid var(--border);
      display: none;
    }

    .tool-group-details.open {
      display: block;
    }

    .tool-group-entry {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.75rem;
      font-size: 0.88rem;
      border-bottom: 1px solid color-mix(in srgb, var(--border) 60%, transparent 40%);
    }

    .tool-group-entry:last-child {
      border-bottom: none;
    }

    .tool-group-entry .tool-entry-name {
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tool-group-entry .tool-entry-status {
      margin-left: auto;
      color: var(--accent-amber);
      font-size: 0.76rem;
      flex-shrink: 0;
    }

    .tool-group-entry .tool-entry-status.done {
      color: var(--accent-green);
    }

    .tool-entry-args {
      padding: 0.25rem 0.75rem 0.35rem 2rem;
      font-size: 0.78rem;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .tool-entry-args .arg-line {
      display: flex;
      gap: 0.4rem;
    }

    .tool-entry-args .arg-label {
      color: var(--text-muted);
      flex-shrink: 0;
    }

    .tool-entry-args .arg-value {
      font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', Menlo, Consolas, monospace;
      color: var(--text);
      white-space: pre-wrap;
      word-break: break-all;
      min-width: 0;
    }

    .markdown-body img {
      max-width: 100%;
      border-radius: 8px;
      margin: 0.5rem 0;
    }

    .composer {
      border-top: 1px solid var(--border);
      background: var(--surface);
      padding: 0.8rem 1rem 0.95rem;
    }

    .composer-inner {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      align-items: flex-end;
      gap: 0.65rem;
    }

    .prompt {
      width: 100%;
      resize: none;
      min-height: 48px;
      max-height: 200px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface-2);
      color: var(--text);
      padding: 0.7rem 0.8rem;
      line-height: 1.4;
      overflow-y: hidden;
    }

    .prompt:focus {
      outline: 2px solid color-mix(in srgb, var(--accent) 65%, transparent);
      outline-offset: 1px;
      border-color: var(--accent);
    }

    .composer-actions {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      flex-shrink: 0;
      margin-bottom: 2px;
    }

    .stop-btn {
      border: 1px solid color-mix(in srgb, var(--danger) 45%, var(--border) 55%);
      background: color-mix(in srgb, var(--danger) 8%, var(--surface-2) 92%);
      color: var(--stop-btn-text);
      border-radius: 10px;
      padding: 0.5rem 0.7rem;
      cursor: pointer;
      display: none;
    }

    .stop-btn.visible {
      display: inline-flex;
    }

    .send-btn {
      width: 44px;
      height: 44px;
      border: 1px solid color-mix(in srgb, var(--accent) 65%, var(--border) 35%);
      border-radius: 999px;
      background: color-mix(in srgb, var(--accent) 32%, var(--surface-2) 68%);
      color: var(--btn-accent-text);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      cursor: pointer;
      position: relative;
      transition: transform 0.15s ease, border-color 0.15s ease;
    }

    .send-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      border-color: var(--accent);
    }

    .send-btn:disabled {
      opacity: 0.72;
      cursor: not-allowed;
    }

    .send-btn .spinner {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid var(--spinner-ring);
      border-top-color: var(--btn-accent-text);
      animation: spin 0.8s linear infinite;
      display: none;
    }

    .send-btn.loading .spinner {
      display: inline-block;
    }

    .send-btn.loading .arrow {
      display: none;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .composer-hint {
      max-width: 900px;
      margin: 0.4rem auto 0;
      font-size: 0.76rem;
      color: var(--text-muted);
      padding: 0 0.2rem;
    }

    .sidebar-backdrop {
      position: fixed;
      inset: 0;
      background: var(--backdrop);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease;
      z-index: 15;
    }

    .sidebar-backdrop.open {
      opacity: 1;
      pointer-events: auto;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: var(--overlay);
      z-index: 60;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    .modal-overlay.hidden {
      display: none;
    }

    .modal {
      width: min(480px, 100%);
      border: 1px solid var(--border);
      background: var(--surface);
      border-radius: 14px;
      padding: 1rem;
      box-shadow: 0 18px 56px rgba(0, 0, 0, 0.45);
    }

    .modal h2 {
      margin: 0 0 0.75rem;
      font-size: 1rem;
    }

    .modal p {
      margin: 0 0 0.75rem;
      color: var(--text-muted);
      font-size: 0.9rem;
      line-height: 1.45;
    }

    .modal input {
      width: 100%;
      border: 1px solid var(--border);
      background: var(--surface-2);
      border-radius: 10px;
      padding: 0.68rem 0.75rem;
    }

    .modal input:focus {
      outline: 2px solid color-mix(in srgb, var(--accent) 60%, transparent);
      border-color: var(--accent);
    }

    .modal-error {
      min-height: 1.1rem;
      color: var(--danger);
      font-size: 0.84rem;
      margin-top: 0.5rem;
    }

    .modal-actions {
      margin-top: 0.75rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.45rem;
      flex-wrap: wrap;
    }

    .btn {
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--surface-2);
      color: var(--text);
      padding: 0.5rem 0.75rem;
      cursor: pointer;
    }

    .btn.primary {
      border-color: color-mix(in srgb, var(--accent) 60%, var(--border) 40%);
      background: color-mix(in srgb, var(--accent) 26%, var(--surface-2) 74%);
      color: var(--btn-accent-text);
      font-weight: 600;
    }

    .btn:disabled {
      opacity: 0.65;
      cursor: not-allowed;
    }

    .attachments {
      display: flex;
      gap: 0.5rem;
      padding: 0 0 0.5rem;
      flex-wrap: wrap;
      max-width: 900px;
      margin: 0 auto;
    }

    .attachment-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.25rem 0.5rem;
      font-size: 0.82rem;
      max-width: 200px;
    }

    .attachment-chip img {
      width: 32px;
      height: 32px;
      object-fit: cover;
      border-radius: 4px;
    }

    .attachment-chip .att-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 0;
    }

    .attachment-chip .att-remove {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0 0.15rem;
      font-size: 1rem;
      line-height: 1;
      flex-shrink: 0;
    }

    .attachment-chip .att-remove:hover {
      color: var(--danger);
    }

    .attach-btn svg {
      width: 18px;
      height: 18px;
    }

    .drop-overlay {
      position: absolute;
      inset: 0;
      background: color-mix(in srgb, var(--accent) 12%, var(--bg) 88%);
      border: 2px dashed var(--accent);
      border-radius: 12px;
      z-index: 50;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      color: var(--accent);
      font-weight: 600;
      pointer-events: none;
    }

    .drop-overlay.hidden {
      display: none;
    }

    .message-attachments {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.4rem;
    }

    .message-attachments img {
      max-width: 200px;
      max-height: 150px;
      border-radius: 8px;
      border: 1px solid var(--border);
      object-fit: cover;
    }

    .message-attachments .att-file {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.82rem;
      color: var(--text-muted);
    }

    @media (max-width: 767px) {
      body {
        overflow: auto;
      }

      .app {
        grid-template-columns: 1fr;
        height: 100dvh;
      }

      .sidebar {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        width: 260px;
        transform: translateX(-102%);
        transition: transform 0.2s ease;
        box-shadow: 18px 0 42px rgba(0, 0, 0, 0.42);
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .sidebar-close {
        display: inline-flex;
      }

      .main {
        min-height: 100dvh;
      }

      .main-header {
        padding: 0.65rem 0.75rem;
      }

      .mobile-menu {
        display: inline-flex;
      }

      .header-title {
        max-width: 52vw;
      }

      .header-right {
        width: 100%;
        margin-left: 0;
      }

      .model-select {
        flex: 1;
        min-width: 0;
      }

      .chat-scroll {
        padding: 0.7rem;
      }

      .composer {
        padding: 0.6rem 0.7rem 0.75rem;
      }

      .message.user {
        width: min(92%, 820px);
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" id="sidebar" aria-label="Sessions">
      <div class="sidebar-header">
        <div class="brand"><span aria-hidden="true">â‰¡</span> <span>Chat</span></div>
        <div style="display:inline-flex; gap:0.4rem;">
          <button class="icon-btn" id="settingsBtn" title="Token settings" aria-label="Token settings">âš™</button>
          <button class="icon-btn sidebar-close" id="sidebarCloseBtn" title="Close sidebar" aria-label="Close sidebar">âœ•</button>
        </div>
      </div>
      <div class="sidebar-content">
        <div class="new-chat-wrap">
          <button class="new-chat-btn" id="newChatBtn">+ New chat</button>
        </div>
        <div class="session-groups" id="sessionGroups"></div>
      </div>
    </aside>

    <div class="sidebar-backdrop" id="sidebarBackdrop"></div>

    <main class="main">
      <header class="main-header">
        <div class="header-left">
          <button class="icon-btn mobile-menu" id="mobileMenuBtn" aria-label="Open sidebar" title="Open sidebar">â˜°</button>
          <h1 class="header-title" id="activeSessionTitle">Chat</h1>
          <span class="connection-state" id="connectionState">Checking tokenâ€¦</span>
        </div>
        <div class="header-right">
          <select class="model-select" id="modelSelect" title="Model selection">
            <option value="">Auto model</option>
          </select>
        </div>
      </header>

      <section class="chat-scroll" id="chatScroll">
        <div class="messages" id="messages"></div>
      </section>

      <div class="drop-overlay hidden" id="dropOverlay">Drop files to attach</div>

      <footer class="composer">
        <div id="attachmentsStrip" class="attachments" style="display:none;"></div>
        <div class="composer-inner">
          <button class="icon-btn attach-btn" id="attachBtn" title="Attach file" aria-label="Attach file">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48"/></svg>
          </button>
          <input type="file" id="fileInput" multiple hidden>
          <textarea id="promptInput" class="prompt" rows="1" placeholder="Messageâ€¦" aria-label="Message"></textarea>
          <div class="composer-actions">
            <button class="stop-btn" id="stopBtn" type="button">Stop</button>
            <button class="send-btn" id="sendBtn" type="button" aria-label="Send message">
              <span class="arrow">â†‘</span>
              <span class="spinner" aria-hidden="true"></span>
            </button>
          </div>
        </div>
        <div class="composer-hint">Enter to send Â· Shift+Enter for newline Â· Paste or drag files to attach</div>
      </footer>
    </main>
  </div>

  <div class="modal-overlay hidden" id="authModal" role="dialog" aria-modal="true" aria-labelledby="authModalTitle">
    <div class="modal">
      <h2 id="authModalTitle">Enter bearer token</h2>
      <p>Uses your API token for <code>/v1/models</code> and <code>/v1/responses</code>.</p>
      <input id="authTokenInput" type="password" placeholder="sk-..." autocomplete="off">
      <div class="modal-error" id="authError"></div>
      <div class="modal-actions">
        <button class="btn" id="authCancelBtn" type="button">Cancel</button>
        <button class="btn primary" id="authConnectBtn" type="button">Connect</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/16.3.0/lib/marked.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.2.7/purify.min.js"></script>
  <script>
    (() => {
      'use strict';

      // ===== Constants & state =====
      const STORAGE_KEYS = {
        sessions: 'term_llm_sessions',
        token: 'term_llm_token',
        activeSession: 'term_llm_active_session',
        selectedModel: 'term_llm_selected_model'
      };

      const state = {
        token: localStorage.getItem(STORAGE_KEYS.token) || '',
        sessions: [],
        activeSessionId: localStorage.getItem(STORAGE_KEYS.activeSession) || '',
        models: [],
        selectedModel: localStorage.getItem(STORAGE_KEYS.selectedModel) || '',
        streaming: false,
        abortController: null,
        autoScroll: true,
        authRequired: false,
        attachments: []
      };

      // Ensure cookie is set on load so <img> requests to /images/ can authenticate
      if (state.token) {
        document.cookie = `term_llm_token=${encodeURIComponent(state.token)}; path=/images; SameSite=Strict; max-age=31536000`;
      }

      const elements = {
        sidebar: document.getElementById('sidebar'),
        sidebarBackdrop: document.getElementById('sidebarBackdrop'),
        sidebarCloseBtn: document.getElementById('sidebarCloseBtn'),
        mobileMenuBtn: document.getElementById('mobileMenuBtn'),
        settingsBtn: document.getElementById('settingsBtn'),
        newChatBtn: document.getElementById('newChatBtn'),
        sessionGroups: document.getElementById('sessionGroups'),
        activeSessionTitle: document.getElementById('activeSessionTitle'),
        connectionState: document.getElementById('connectionState'),
        modelSelect: document.getElementById('modelSelect'),
        chatScroll: document.getElementById('chatScroll'),
        messages: document.getElementById('messages'),
        promptInput: document.getElementById('promptInput'),
        sendBtn: document.getElementById('sendBtn'),
        stopBtn: document.getElementById('stopBtn'),
        authModal: document.getElementById('authModal'),
        authTokenInput: document.getElementById('authTokenInput'),
        authError: document.getElementById('authError'),
        authConnectBtn: document.getElementById('authConnectBtn'),
        authCancelBtn: document.getElementById('authCancelBtn'),
        attachBtn: document.getElementById('attachBtn'),
        fileInput: document.getElementById('fileInput'),
        attachmentsStrip: document.getElementById('attachmentsStrip'),
        dropOverlay: document.getElementById('dropOverlay')
      };

      // ===== Markdown setup =====
      marked.use({
        breaks: true,
        gfm: true
      });

      // ===== Helpers =====
      // crypto.randomUUID() requires a secure context (HTTPS); use getRandomValues fallback for HTTP
      const generateUUID = () => {
        if (typeof crypto !== 'undefined' && crypto.randomUUID) {
          return crypto.randomUUID();
        }
        // Works on HTTP â€” getRandomValues is not restricted to secure contexts
        if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
          return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
          );
        }
        // Last resort
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
          const r = Math.random() * 16 | 0;
          return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
      };
      const generateId = (prefix) => `${prefix}_${generateUUID()}`;

      const syncTokenCookie = (token) => {
        if (token) {
          document.cookie = `term_llm_token=${encodeURIComponent(token)}; path=/images; SameSite=Strict; max-age=31536000`;
        } else {
          document.cookie = 'term_llm_token=; path=/images; SameSite=Strict; max-age=0';
        }
      };

      const truncate = (text, max = 60) => {
        const value = (text || '').trim().replace(/\s+/g, ' ');
        if (!value) return 'New chat';
        return value.length > max ? `${value.slice(0, max - 1)}â€¦` : value;
      };

      const asTimestamp = (value) => {
        const n = Number(value);
        return Number.isFinite(n) && n > 0 ? n : Date.now();
      };

      const fullDate = (ms) => new Date(ms).toLocaleString();

      const relativeTime = (ms) => {
        const diff = Date.now() - ms;
        if (diff < 45_000) return 'just now';
        if (diff < 3_600_000) return `${Math.max(1, Math.floor(diff / 60_000))}m ago`;
        if (diff < 86_400_000) return `${Math.max(1, Math.floor(diff / 3_600_000))}h ago`;
        if (diff < 604_800_000) return `${Math.max(1, Math.floor(diff / 86_400_000))}d ago`;
        return new Date(ms).toLocaleDateString();
      };

      const sessionBucket = (ms) => {
        const now = new Date();
        const startToday = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
        const startYesterday = startToday - 86_400_000;
        const startWeek = startToday - (6 * 86_400_000);

        if (ms >= startToday) return 'Today';
        if (ms >= startYesterday) return 'Yesterday';
        if (ms >= startWeek) return 'This week';
        return 'Older';
      };

      const toolIcon = (name) => {
        const n = String(name || '').toLowerCase();
        if (n === 'shell' || n === 'bash') return 'ðŸ’»';
        if (n === 'read_file') return 'ðŸ“„';
        if (n === 'write_file' || n === 'edit_file') return 'âœï¸';
        if (n === 'web_search') return 'ðŸ”';
        if (n === 'read_url') return 'ðŸŒ';
        if (n === 'image_generate') return 'ðŸŽ¨';
        if (n === 'spawn_agent') return 'ðŸ¤–';
        return 'ðŸ”§';
      };

      const formatUsage = (usage) => {
        const inTokens = Number(usage?.input_tokens || 0);
        const outTokens = Number(usage?.output_tokens || 0);
        const cached = Number(usage?.input_tokens_details?.cached_tokens || 0);
        return `â†™ ${inTokens.toLocaleString()} in Â· ${outTokens.toLocaleString()} out Â· ${cached.toLocaleString()} cached`;
      };

      const isNearBottom = () => {
        const el = elements.chatScroll;
        return (el.scrollHeight - (el.scrollTop + el.clientHeight)) < 96;
      };

      const scrollToBottom = (force = false) => {
        if (force || state.autoScroll) {
          elements.chatScroll.scrollTop = elements.chatScroll.scrollHeight;
        }
      };

      const setConnectionState = (text, mode = '') => {
        elements.connectionState.textContent = text;
        elements.connectionState.classList.remove('ok', 'bad');
        if (mode) {
          elements.connectionState.classList.add(mode);
        }
      };

      const updateDocumentTitle = () => {
        const session = getActiveSession();
        if (session && session.title && session.title !== 'New chat') {
          document.title = `Chat Â· ${session.title}`;
        } else {
          document.title = 'Chat';
        }
      };

      const sessionIdFromURL = () => {
        const path = window.location.pathname;
        const match = path.match(/^\/ui\/(.+)$/);
        return match ? decodeURIComponent(match[1]) : '';
      };

      const updateURL = (sessionId) => {
        if (!sessionId) return;
        const target = '/ui/' + encodeURIComponent(sessionId);
        if (window.location.pathname !== target) {
          history.pushState(null, '', target);
        }
        updateDocumentTitle();
      };

      const sanitizeMessage = (msg) => {
        if (!msg || typeof msg !== 'object' || typeof msg.role !== 'string') return null;
        const role = msg.role;
        const base = {
          id: typeof msg.id === 'string' ? msg.id : generateId('msg'),
          role,
          created: asTimestamp(msg.created)
        };

        if (role === 'user' || role === 'assistant' || role === 'error') {
          base.content = String(msg.content || '');
          if (role === 'assistant' && msg.usage && typeof msg.usage === 'object') {
            base.usage = msg.usage;
          }
          if (role === 'user' && Array.isArray(msg.attachments) && msg.attachments.length > 0) {
            base.attachments = msg.attachments.map(a => ({
              name: String(a.name || 'file'),
              type: String(a.type || '')
            }));
          }
          return base;
        }

        if (role === 'tool') {
          base.name = String(msg.name || 'tool');
          base.arguments = String(msg.arguments || '');
          base.status = msg.status === 'done' ? 'done' : 'running';
          base.expanded = Boolean(msg.expanded);
          return base;
        }

        if (role === 'tool-group') {
          base.tools = Array.isArray(msg.tools) ? msg.tools.map(t => ({
            id: String(t.id || ''),
            name: String(t.name || 'tool'),
            arguments: String(t.arguments || ''),
            status: t.status === 'done' ? 'done' : 'running',
            created: asTimestamp(t.created)
          })) : [];
          base.expanded = Boolean(msg.expanded);
          base.status = msg.status === 'done' ? 'done' : 'running';
          return base;
        }

        return null;
      };

      const sanitizeSession = (session) => {
        if (!session || typeof session !== 'object') return null;
        const messages = Array.isArray(session.messages)
          ? session.messages.map(sanitizeMessage).filter(Boolean)
          : [];

        const result = {
          id: typeof session.id === 'string' ? session.id : `sess_${generateUUID()}`,
          title: typeof session.title === 'string' && session.title.trim() ? session.title.trim() : 'New chat',
          created: asTimestamp(session.created),
          messages
        };
        if (session._serverOnly) result._serverOnly = true;
        if (typeof session.messageCount === 'number') result.messageCount = session.messageCount;
        return result;
      };

      const loadSessions = () => {
        try {
          const raw = localStorage.getItem(STORAGE_KEYS.sessions);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed.map(sanitizeSession).filter(Boolean);
        } catch {
          return [];
        }
      };

      // Strip large binary payloads from attachment metadata before serialization.
      const sessionsForStorage = () => {
        return state.sessions.map(s => {
          if (!s.messages || !s.messages.some(m => m.attachments)) return s;
          return {
            ...s,
            messages: s.messages.map(m => {
              if (!m.attachments) return m;
              return {
                ...m,
                attachments: m.attachments.map(a => ({ name: a.name, type: a.type }))
              };
            })
          };
        });
      };

      const saveSessions = () => {
        if (state.sessions.length > 100) {
          state.sessions.sort((a, b) => a.created - b.created);
          state.sessions = state.sessions.slice(-100);
          if (!state.sessions.find((s) => s.id === state.activeSessionId)) {
            state.activeSessionId = state.sessions[state.sessions.length - 1]?.id || '';
          }
        }
        try {
          localStorage.setItem(STORAGE_KEYS.sessions, JSON.stringify(sessionsForStorage()));
          localStorage.setItem(STORAGE_KEYS.activeSession, state.activeSessionId || '');
        } catch {
          // QuotaExceededError or other storage failure â€” continue without persistence
        }
      };

      const getActiveSession = () => state.sessions.find((s) => s.id === state.activeSessionId) || null;

      const createSession = () => ({
        id: `sess_${generateUUID()}`,
        title: 'New chat',
        created: Date.now(),
        messages: []
      });

      const ensureActiveSession = () => {
        let active = getActiveSession();
        if (active) {
          updateURL(active.id);
          return active;
        }

        if (state.sessions.length === 0) {
          active = createSession();
          state.sessions.unshift(active);
        } else {
          const sorted = [...state.sessions].sort((a, b) => b.created - a.created);
          active = sorted[0];
        }

        state.activeSessionId = active.id;
        updateURL(active.id);
        saveSessions();
        return active;
      };

      const findMessageElement = (id) => elements.messages.querySelector(`[data-message-id="${id}"]`);

      const refreshRelativeTimes = () => {
        document.querySelectorAll('[data-created]').forEach((node) => {
          const ts = Number(node.getAttribute('data-created'));
          if (!Number.isFinite(ts)) return;
          node.textContent = relativeTime(ts);
          node.title = fullDate(ts);
        });
      };

      const persistAndRefreshShell = () => {
        saveSessions();
        renderSidebar();
        updateHeader();
      };

      // ===== Sidebar & header =====
      const openSidebar = () => {
        elements.sidebar.classList.add('open');
        elements.sidebarBackdrop.classList.add('open');
      };

      const closeSidebar = () => {
        elements.sidebar.classList.remove('open');
        elements.sidebarBackdrop.classList.remove('open');
      };

      const closeSidebarIfMobile = () => {
        if (window.matchMedia('(max-width: 767px)').matches) {
          closeSidebar();
        }
      };

      const updateHeader = () => {
        const session = ensureActiveSession();
        elements.activeSessionTitle.textContent = session.title || 'Chat';
        updateDocumentTitle();
      };

      const renderSidebar = () => {
        const grouped = {
          Today: [],
          Yesterday: [],
          'This week': [],
          Older: []
        };

        const sorted = [...state.sessions].sort((a, b) => b.created - a.created);
        sorted.forEach((session) => {
          grouped[sessionBucket(session.created)].push(session);
        });

        elements.sessionGroups.innerHTML = '';

        Object.entries(grouped).forEach(([label, sessions]) => {
          if (!sessions.length) return;

          const groupEl = document.createElement('section');
          groupEl.className = 'session-group';

          const heading = document.createElement('h3');
          heading.textContent = label;
          groupEl.appendChild(heading);

          sessions.forEach((session) => {
            const btn = document.createElement('button');
            btn.className = 'session-btn';
            if (session.id === state.activeSessionId) {
              btn.classList.add('active');
            }

            const title = document.createElement('div');
            title.className = 'session-title';
            title.textContent = session.title || 'New chat';

            const meta = document.createElement('div');
            meta.className = 'session-meta';
            const msgCount = session.messages.length || session.messageCount || 0;
            meta.textContent = `${msgCount} message${msgCount === 1 ? '' : 's'} Â· ${relativeTime(session.created)}`;
            meta.title = fullDate(session.created);

            btn.appendChild(title);
            btn.appendChild(meta);
            btn.addEventListener('click', async () => {
              state.activeSessionId = session.id;
              updateURL(session.id);

              // Lazy-load messages for server-only sessions
              if (session._serverOnly) {
                const msgs = await loadServerSessionMessages(session.id);
                if (msgs !== null) {
                  session.messages = msgs;
                  delete session._serverOnly;
                }
              }

              persistAndRefreshShell();
              renderMessages(true);
              closeSidebarIfMobile();
            });

            groupEl.appendChild(btn);
          });

          elements.sessionGroups.appendChild(groupEl);
        });
      };

      // ===== Message rendering =====
      const createMetaNode = (created) => {
        const meta = document.createElement('div');
        meta.className = 'message-meta';

        const time = document.createElement('span');
        time.setAttribute('data-created', String(created));
        time.textContent = relativeTime(created);
        time.title = fullDate(created);

        meta.appendChild(time);
        return meta;
      };

      const renderAssistantMarkdown = (target, content) => {
        const html = marked.parse(content || '');
        const clean = DOMPurify.sanitize(html);
        target.innerHTML = clean;

        target.querySelectorAll('a').forEach((a) => {
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
        });

        target.querySelectorAll('pre code').forEach((code) => {
          hljs.highlightElement(code);
        });
      };

      const createToolCard = (message) => {
        const wrapper = document.createElement('article');
        wrapper.className = 'message tool';
        wrapper.dataset.messageId = message.id;

        const card = document.createElement('div');
        card.className = 'tool-card';

        const toggle = document.createElement('button');
        toggle.className = 'tool-toggle';
        toggle.type = 'button';
        toggle.setAttribute('aria-expanded', message.expanded ? 'true' : 'false');

        const arrow = document.createElement('span');
        arrow.className = 'tool-arrow';
        arrow.textContent = 'â–¶';

        const name = document.createElement('span');
        name.className = 'tool-name';
        name.textContent = `${toolIcon(message.name)} ${message.name || 'tool'}`;

        const status = document.createElement('span');
        status.className = `tool-status${message.status === 'done' ? ' done' : ''}`;
        status.textContent = message.status === 'done' ? '[done]' : '[runningâ€¦]';

        const details = document.createElement('div');
        details.className = `tool-details${message.expanded ? ' open' : ''}`;

        const label = document.createElement('div');
        label.className = 'tool-details-label';
        label.textContent = 'Arguments:';

        const args = document.createElement('pre');
        args.textContent = message.arguments || '(waiting for argumentsâ€¦)';

        details.appendChild(label);
        details.appendChild(args);

        toggle.appendChild(arrow);
        toggle.appendChild(name);
        toggle.appendChild(status);

        toggle.addEventListener('click', () => {
          message.expanded = !message.expanded;
          toggle.setAttribute('aria-expanded', message.expanded ? 'true' : 'false');
          details.classList.toggle('open', message.expanded);
          saveSessions();
        });

        card.appendChild(toggle);
        card.appendChild(details);

        wrapper.appendChild(card);
        wrapper.appendChild(createMetaNode(message.created));
        return wrapper;
      };

      const createMessageNode = (message) => {
        if (message.role === 'tool') return createToolCard(message);
        if (message.role === 'tool-group') return createToolGroupNode(message);

        const article = document.createElement('article');
        article.className = `message ${message.role}`;
        article.dataset.messageId = message.id;

        const body = document.createElement('div');
        body.className = 'message-body';

        if (message.role === 'assistant') {
          body.classList.add('markdown-body');
          renderAssistantMarkdown(body, message.content || '');
        } else if (message.role === 'error') {
          body.textContent = `Error: ${message.content || 'Unknown error.'}`;
        } else {
          // User message: show attachments if present
          if (message.attachments && message.attachments.length > 0) {
            const attDiv = document.createElement('div');
            attDiv.className = 'message-attachments';
            message.attachments.forEach(att => {
              if (att.type && att.type.startsWith('image/') && att.dataURL) {
                const img = document.createElement('img');
                img.src = att.dataURL;
                img.alt = att.name || 'Attached image';
                attDiv.appendChild(img);
              } else {
                const badge = document.createElement('span');
                badge.className = 'att-file';
                badge.textContent = att.name || 'file';
                attDiv.appendChild(badge);
              }
            });
            body.appendChild(attDiv);
          }
          if (message.content) {
            const textNode = document.createTextNode(message.content);
            body.appendChild(textNode);
          }
        }

        article.appendChild(body);

        if (message.role === 'assistant' && message.usage) {
          const usage = document.createElement('div');
          usage.className = 'usage-line';
          usage.textContent = formatUsage(message.usage);
          article.appendChild(usage);
        }

        article.appendChild(createMetaNode(message.created));
        return article;
      };

      const updateAssistantNode = (message) => {
        let node = findMessageElement(message.id);
        if (!node) {
          node = createMessageNode(message);
          elements.messages.appendChild(node);
        }

        const body = node.querySelector('.message-body');
        if (!body) return;
        renderAssistantMarkdown(body, message.content || '');

        let usageNode = node.querySelector('.usage-line');
        if (message.usage) {
          if (!usageNode) {
            usageNode = document.createElement('div');
            usageNode.className = 'usage-line';
            node.insertBefore(usageNode, node.querySelector('.message-meta'));
          }
          usageNode.textContent = formatUsage(message.usage);
        } else if (usageNode) {
          usageNode.remove();
        }
      };

      const updateToolNode = (message) => {
        let node = findMessageElement(message.id);
        if (!node) {
          node = createToolCard(message);
          elements.messages.appendChild(node);
          return;
        }

        const toggle = node.querySelector('.tool-toggle');
        const status = node.querySelector('.tool-status');
        const details = node.querySelector('.tool-details');
        const args = node.querySelector('.tool-details pre');
        const name = node.querySelector('.tool-name');

        if (name) {
          name.textContent = `${toolIcon(message.name)} ${message.name || 'tool'}`;
        }
        if (status) {
          status.className = `tool-status${message.status === 'done' ? ' done' : ''}`;
          status.textContent = message.status === 'done' ? '[done]' : '[runningâ€¦]';
        }
        if (toggle) {
          toggle.setAttribute('aria-expanded', message.expanded ? 'true' : 'false');
        }
        if (details) {
          details.classList.toggle('open', Boolean(message.expanded));
        }
        if (args) {
          args.textContent = message.arguments || '(waiting for argumentsâ€¦)';
        }
      };

      const toolGroupSummaryText = (message) => {
        const total = message.tools.length;
        const done = message.tools.filter(t => t.status === 'done').length;
        if (message.status === 'done' || done === total) {
          return `${total} tool call${total === 1 ? '' : 's'} completed`;
        }
        return `Running ${total} tool${total === 1 ? '' : 's'}â€¦ (${done}/${total} done)`;
      };

      const createToolGroupNode = (message) => {
        const wrapper = document.createElement('article');
        wrapper.className = 'message tool-group';
        wrapper.dataset.messageId = message.id;

        const card = document.createElement('div');
        card.className = 'tool-group-card';

        const toggle = document.createElement('button');
        toggle.className = 'tool-group-toggle';
        toggle.type = 'button';
        toggle.setAttribute('aria-expanded', message.expanded ? 'true' : 'false');

        const arrow = document.createElement('span');
        arrow.className = 'tool-arrow';
        arrow.textContent = 'â–¶';

        const summary = document.createElement('span');
        summary.className = 'tool-group-summary';
        summary.textContent = toolGroupSummaryText(message);

        const statusBadge = document.createElement('span');
        statusBadge.className = 'tool-status';
        if (message.status === 'done') {
          statusBadge.style.display = 'none';
          statusBadge.textContent = '';
        } else {
          statusBadge.textContent = 'running\u2026';
        }

        toggle.appendChild(arrow);
        toggle.appendChild(summary);
        toggle.appendChild(statusBadge);

        const details = document.createElement('div');
        details.className = `tool-group-details${message.expanded ? ' open' : ''}`;

        message.tools.forEach(tool => {
          details.appendChild(createToolEntryNode(tool));
        });

        toggle.addEventListener('click', () => {
          message.expanded = !message.expanded;
          toggle.setAttribute('aria-expanded', message.expanded ? 'true' : 'false');
          details.classList.toggle('open', message.expanded);
          saveSessions();
        });

        card.appendChild(toggle);
        card.appendChild(details);
        wrapper.appendChild(card);
        wrapper.appendChild(createMetaNode(message.created));
        return wrapper;
      };

      const formatToolArgs = (tool) => {
        if (!tool.arguments) return null;
        let args;
        try {
          args = typeof tool.arguments === 'string' ? JSON.parse(tool.arguments) : tool.arguments;
        } catch { return null; }
        if (!args || typeof args !== 'object') return null;

        const name = (tool.name || '').toLowerCase();

        // spawn_agent: show "@agent_name: truncated prompt"
        if (name === 'spawn_agent') {
          const agentName = args.agent_name || 'agent';
          let prompt = args.prompt || '';
          if (prompt.length > 120) prompt = prompt.slice(0, 117) + 'â€¦';
          return [['task', '@' + agentName + ': ' + prompt]];
        }

        // Pick the most relevant key(s) per tool type
        const priorityKeys = {
          'shell': ['command'],
          'bash': ['command'],
          'read_file': ['path', 'file_path'],
          'write_file': ['path', 'file_path'],
          'edit_file': ['path', 'file_path'],
          'web_search': ['query'],
          'search': ['query'],
          'grep': ['pattern', 'path'],
          'glob': ['pattern', 'path'],
        };

        const pick = priorityKeys[name];
        let entries;
        if (pick) {
          entries = pick.filter(k => args[k] != null).map(k => [k, args[k]]);
          // If no priority keys matched, fall back to all keys
          if (entries.length === 0) entries = Object.entries(args);
        } else {
          entries = Object.entries(args);
        }

        return entries.slice(0, 4); // Cap at 4 args to keep it compact
      };

      const buildArgsNode = (tool) => {
        const entries = formatToolArgs(tool);
        if (!entries || entries.length === 0) return null;

        const argsDiv = document.createElement('div');
        argsDiv.className = 'tool-entry-args';

        entries.forEach(([key, value]) => {
          const line = document.createElement('div');
          line.className = 'arg-line';

          const label = document.createElement('span');
          label.className = 'arg-label';
          label.textContent = key + ':';

          const val = document.createElement('span');
          val.className = 'arg-value';
          val.textContent = typeof value === 'string' ? value : JSON.stringify(value);

          line.appendChild(label);
          line.appendChild(val);
          argsDiv.appendChild(line);
        });

        return argsDiv;
      };

      const createToolEntryNode = (tool) => {
        const wrapper = document.createElement('div');
        wrapper.dataset.toolId = tool.id;

        const entry = document.createElement('div');
        entry.className = 'tool-group-entry';

        const icon = document.createElement('span');
        icon.textContent = toolIcon(tool.name);

        const name = document.createElement('span');
        name.className = 'tool-entry-name';
        name.textContent = tool.name || 'tool';

        const status = document.createElement('span');
        status.className = `tool-entry-status${tool.status === 'done' ? ' done' : ''}`;
        status.textContent = tool.status === 'done' ? 'âœ“' : 'â€¦';

        entry.appendChild(icon);
        entry.appendChild(name);
        entry.appendChild(status);
        wrapper.appendChild(entry);

        const argsNode = buildArgsNode(tool);
        if (argsNode) wrapper.appendChild(argsNode);

        return wrapper;
      };

      const updateToolGroupNode = (message) => {
        let node = findMessageElement(message.id);
        if (!node) {
          node = createToolGroupNode(message);
          elements.messages.appendChild(node);
          return;
        }

        const summary = node.querySelector('.tool-group-summary');
        if (summary) summary.textContent = toolGroupSummaryText(message);

        const statusBadge = node.querySelector('.tool-status');
        if (statusBadge) {
          if (message.status === 'done') {
            statusBadge.style.display = 'none';
            statusBadge.textContent = '';
          } else {
            statusBadge.style.display = '';
            statusBadge.textContent = 'running\u2026';
          }
        }

        const details = node.querySelector('.tool-group-details');
        if (details) {
          // Update existing entries or add new ones
          message.tools.forEach(tool => {
            let entry = details.querySelector(`[data-tool-id="${CSS.escape(tool.id)}"]`);
            if (!entry) {
              entry = createToolEntryNode(tool);
              details.appendChild(entry);
            } else {
              const status = entry.querySelector('.tool-entry-status');
              if (status) {
                status.className = `tool-entry-status${tool.status === 'done' ? ' done' : ''}`;
                status.textContent = tool.status === 'done' ? 'âœ“' : 'â€¦';
              }
              // Update or add arguments display
              const existingArgs = entry.querySelector('.tool-entry-args');
              const newArgs = buildArgsNode(tool);
              if (existingArgs && newArgs) {
                existingArgs.replaceWith(newArgs);
              } else if (!existingArgs && newArgs) {
                entry.appendChild(newArgs);
              }
            }
          });
        }
      };

      const renderMessages = (forceScroll = false) => {
        const session = ensureActiveSession();
        elements.messages.innerHTML = '';

        if (!session.messages.length) {
          const empty = document.createElement('div');
          empty.className = 'empty-state';
          empty.innerHTML = '<p><strong>Start a new conversation</strong></p><p>Type a prompt below to begin.</p>';
          elements.messages.appendChild(empty);
        } else {
          session.messages.forEach((message) => {
            elements.messages.appendChild(createMessageNode(message));
          });
        }

        refreshRelativeTimes();
        scrollToBottom(forceScroll);
        updateHeader();
      };

      // ===== Network helpers =====
      const requestHeaders = (sessionId, tokenOverride = '') => {
        const headers = {
          'Content-Type': 'application/json'
        };

        const token = tokenOverride || state.token;
        if (token) {
          headers.Authorization = `Bearer ${token}`;
        }
        if (sessionId) {
          headers.session_id = sessionId;
        }

        return headers;
      };

      const normalizeError = async (response) => {
        let message = `Request failed (${response.status}).`;
        let parsed;

        try {
          parsed = await response.json();
        } catch {
          parsed = null;
        }

        if (response.status === 401) {
          message = 'Auth failed â€” check your token.';
        } else if (response.status === 429) {
          message = 'Rate limited. Try again shortly.';
        } else if (parsed?.error?.message) {
          message = parsed.error.message;
        }

        return { status: response.status, message };
      };

      const fetchModels = async (tokenOverride = '') => {
        const headers = {};
        const token = tokenOverride || state.token;
        if (token) headers.Authorization = `Bearer ${token}`;

        const response = await fetch('/v1/models', { headers });
        if (!response.ok) {
          throw await normalizeError(response);
        }

        const data = await response.json().catch(() => ({ data: [] }));
        return Array.isArray(data.data)
          ? data.data.map((m) => m?.id).filter(Boolean)
          : [];
      };

      const parseSSEStream = async (stream, onEvent) => {
        const reader = stream.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        const processBlock = async (block) => {
          if (!block.trim()) return true;

          let eventName = '';
          const dataLines = [];
          const lines = block.split('\n');

          for (const line of lines) {
            if (line.startsWith('event:')) {
              eventName = line.slice(6).trim();
            } else if (line.startsWith('data:')) {
              dataLines.push(line.slice(5).trimStart());
            }
          }

          return onEvent(eventName, dataLines.join('\n'));
        };

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true }).replace(/\r/g, '');

          let idx;
          while ((idx = buffer.indexOf('\n\n')) !== -1) {
            const block = buffer.slice(0, idx);
            buffer = buffer.slice(idx + 2);
            const keepGoing = await processBlock(block);
            if (keepGoing === false) {
              reader.cancel().catch(() => {});
              return;
            }
          }
        }

        if (buffer.trim()) {
          await processBlock(buffer);
        }
      };

      // ===== Auth modal =====
      const openAuthModal = (errorText = '', required = !state.token) => {
        state.authRequired = required;
        elements.authError.textContent = errorText;
        elements.authTokenInput.value = state.token || '';
        elements.authCancelBtn.style.display = required ? 'none' : 'inline-flex';
        elements.authModal.classList.remove('hidden');

        setTimeout(() => {
          elements.authTokenInput.focus();
          elements.authTokenInput.select();
        }, 0);
      };

      const closeAuthModal = () => {
        if (state.authRequired && !state.token) return;
        elements.authModal.classList.add('hidden');
        elements.authError.textContent = '';
      };

      const handleAuthFailure = () => {
        state.token = '';
        localStorage.removeItem(STORAGE_KEYS.token);
        syncTokenCookie('');
        setConnectionState('Not connected', 'bad');
        openAuthModal('Auth failed â€” check your token.', true);
      };

      const connectToken = async () => {
        const token = elements.authTokenInput.value.trim();
        if (!token) {
          elements.authError.textContent = 'Token is required.';
          return;
        }

        elements.authConnectBtn.disabled = true;
        elements.authConnectBtn.textContent = 'Connectingâ€¦';
        elements.authError.textContent = '';

        try {
          const models = await fetchModels(token);
          state.token = token;
          state.models = models;
          localStorage.setItem(STORAGE_KEYS.token, token);
          syncTokenCookie(token);

          renderModelOptions();
          setConnectionState('', '');
          state.authRequired = false;
          closeAuthModal();
        } catch (err) {
          const message = err?.message || 'Unable to validate token.';
          elements.authError.textContent = message;
          if (err?.status === 401) {
            state.token = '';
            localStorage.removeItem(STORAGE_KEYS.token);
            syncTokenCookie('');
          }
          setConnectionState('Not connected', 'bad');
        } finally {
          elements.authConnectBtn.disabled = false;
          elements.authConnectBtn.textContent = 'Connect';
        }
      };

      // ===== Model picker =====
      const renderModelOptions = () => {
        const previous = state.selectedModel;
        elements.modelSelect.innerHTML = '';

        const autoOption = document.createElement('option');
        autoOption.value = '';
        autoOption.textContent = 'Auto model';
        elements.modelSelect.appendChild(autoOption);

        state.models.forEach((id) => {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = id;
          elements.modelSelect.appendChild(option);
        });

        if (previous && !state.models.includes(previous)) {
          const custom = document.createElement('option');
          custom.value = previous;
          custom.textContent = `${previous} (custom)`;
          elements.modelSelect.appendChild(custom);
        }

        elements.modelSelect.value = previous;
      };

      // ===== Composer logic =====
      const autoGrowPrompt = () => {
        const el = elements.promptInput;
        el.style.height = 'auto';
        const next = Math.min(el.scrollHeight, 200);
        el.style.height = `${Math.max(48, next)}px`;
        el.style.overflowY = el.scrollHeight > 200 ? 'auto' : 'hidden';
      };

      // ===== File attachment =====
      const renderAttachments = () => {
        const strip = elements.attachmentsStrip;
        strip.innerHTML = '';
        if (state.attachments.length === 0) {
          strip.style.display = 'none';
          return;
        }
        strip.style.display = 'flex';
        state.attachments.forEach((att) => {
          const chip = document.createElement('div');
          chip.className = 'attachment-chip';

          if (att.type.startsWith('image/')) {
            const img = document.createElement('img');
            img.src = att.dataURL;
            img.alt = att.name;
            chip.appendChild(img);
          }

          const name = document.createElement('span');
          name.className = 'att-name';
          name.textContent = att.name;
          name.title = `${att.name} (${(att.size / 1024).toFixed(1)} KB)`;
          chip.appendChild(name);

          const remove = document.createElement('button');
          remove.className = 'att-remove';
          remove.textContent = '\u00d7';
          remove.title = 'Remove';
          remove.addEventListener('click', () => {
            state.attachments = state.attachments.filter(a => a.id !== att.id);
            renderAttachments();
          });
          chip.appendChild(remove);

          strip.appendChild(chip);
        });
      };

      const MAX_ATTACHMENTS = 10;
      const MAX_FILE_BYTES = 20 * 1024 * 1024; // 20 MB

      const handleFiles = (fileList) => {
        const files = Array.from(fileList);
        for (const file of files) {
          if (state.attachments.length >= MAX_ATTACHMENTS) {
            alert(`Maximum ${MAX_ATTACHMENTS} attachments allowed.`);
            return;
          }
          if (file.size > MAX_FILE_BYTES) {
            alert(`${file.name} exceeds the 20 MB file size limit.`);
            continue;
          }
          const reader = new FileReader();
          reader.onload = () => {
            if (state.attachments.length >= MAX_ATTACHMENTS) return;
            const dataURL = reader.result;
            state.attachments.push({
              id: generateId('att'),
              name: file.name,
              type: file.type || 'application/octet-stream',
              size: file.size,
              dataURL
            });
            renderAttachments();
          };
          reader.readAsDataURL(file);
        }
      };

      const setStreaming = (streaming) => {
        state.streaming = streaming;
        elements.promptInput.disabled = streaming;
        elements.sendBtn.disabled = streaming;
        elements.sendBtn.classList.toggle('loading', streaming);
        elements.stopBtn.classList.toggle('visible', streaming);
        if (!streaming) {
          elements.promptInput.focus();
        }
      };

      const addErrorMessage = (text, session) => {
        const message = {
          id: generateId('msg'),
          role: 'error',
          content: text,
          created: Date.now()
        };
        session.messages.push(message);
        elements.messages.appendChild(createMessageNode(message));
      };

      const markToolGroupsDone = (session) => {
        session.messages.forEach(m => {
          if (m.role === 'tool-group' && m.status === 'running') {
            m.tools.forEach(t => { t.status = 'done'; });
            m.status = 'done';
            updateToolGroupNode(m);
          }
          if (m.role === 'tool' && m.status === 'running') {
            m.status = 'done';
            updateToolNode(m);
          }
        });
      };

      const sendMessage = async () => {
        if (state.streaming) return;

        const prompt = elements.promptInput.value.trim();
        const pendingAttachments = [...state.attachments];
        if (!prompt && pendingAttachments.length === 0) return;

        if (!state.token) {
          openAuthModal('Enter a token before sending a message.', true);
          return;
        }

        const session = ensureActiveSession();
        let currentAssistantMessage = null;
        let currentToolGroup = null;

        const ensureAssistantMessage = () => {
          if (currentAssistantMessage) return currentAssistantMessage;
          const msg = {
            id: generateId('msg'),
            role: 'assistant',
            content: '',
            created: Date.now()
          };
          session.messages.push(msg);
          elements.messages.appendChild(createMessageNode(msg));
          currentAssistantMessage = msg;
          return msg;
        };

        const closeToolGroup = () => {
          if (currentToolGroup) {
            currentToolGroup.tools.forEach(t => { t.status = 'done'; });
            currentToolGroup.status = 'done';
            updateToolGroupNode(currentToolGroup);
            currentToolGroup = null;
          }
        };

        // user message
        const userMessage = {
          id: generateId('msg'),
          role: 'user',
          content: prompt,
          created: Date.now()
        };
        if (pendingAttachments.length > 0) {
          userMessage.attachments = pendingAttachments.map(a => ({
            name: a.name,
            type: a.type,
            dataURL: a.dataURL
          }));
        }
        session.messages.push(userMessage);

        if (!session.title || session.title === 'New chat') {
          session.title = truncate(prompt || pendingAttachments[0]?.name || 'Image', 60);
        }

        const hadEmptyState = elements.messages.querySelector('.empty-state');
        if (hadEmptyState) hadEmptyState.remove();

        // Render user message; assistant message is created lazily on first text/image event
        const userNode = createMessageNode(userMessage);
        elements.messages.appendChild(userNode);

        persistAndRefreshShell();

        elements.promptInput.value = '';
        state.attachments = [];
        renderAttachments();
        autoGrowPrompt();
        scrollToBottom(true);

        setStreaming(true);
        const controller = new AbortController();
        state.abortController = controller;

        // Build input content: plain string or array with file/image parts
        let inputContent;
        if (pendingAttachments.length > 0) {
          const contentParts = [];
          for (const att of pendingAttachments) {
            if (att.type.startsWith('image/')) {
              contentParts.push({ type: 'input_image', image_url: att.dataURL, filename: att.name });
            } else {
              contentParts.push({ type: 'input_file', file_data: att.dataURL, filename: att.name });
            }
          }
          if (prompt) {
            contentParts.push({ type: 'input_text', text: prompt });
          }
          inputContent = contentParts;
        } else {
          inputContent = prompt;
        }

        const body = {
          stream: true,
          input: [{ type: 'message', role: 'user', content: inputContent }]
        };

        if (state.selectedModel) {
          body.model = state.selectedModel;
        }

        try {
          const response = await fetch('/v1/responses', {
            method: 'POST',
            headers: requestHeaders(session.id),
            body: JSON.stringify(body),
            signal: controller.signal
          });

          if (!response.ok) {
            throw await normalizeError(response);
          }

          if (!response.body) {
            throw { status: 0, message: 'No response body from server.' };
          }

          await parseSSEStream(response.body, async (event, data) => {
            if (data === '[DONE]') {
              closeToolGroup();
              markToolGroupsDone(session);
              persistAndRefreshShell();
              return false;
            }

            if (!data) return true;

            let payload;
            try {
              payload = JSON.parse(data);
            } catch {
              return true;
            }

            if (event === 'response.output_text.delta') {
              const delta = String(payload.delta || '');
              if (delta) {
                closeToolGroup();
                const msg = ensureAssistantMessage();
                msg.content += delta;
                updateAssistantNode(msg);
                saveSessions();
                scrollToBottom();
              }
              return true;
            }

            if (event === 'response.output_text.new_segment') {
              closeToolGroup();
              // Start a new assistant message segment
              currentAssistantMessage = null;
              ensureAssistantMessage();
              saveSessions();
              scrollToBottom();
              return true;
            }

            if (event === 'response.output_item.added') {
              const item = payload.item;
              if (item?.type === 'function_call') {
                const toolEntry = {
                  id: item.call_id || generateId('tool'),
                  name: String(item.name || 'tool'),
                  arguments: String(item.arguments || ''),
                  status: 'running',
                  created: Date.now()
                };

                if (!currentToolGroup) {
                  currentToolGroup = {
                    id: generateId('msg'),
                    role: 'tool-group',
                    tools: [toolEntry],
                    expanded: false,
                    status: 'running',
                    created: Date.now()
                  };
                  session.messages.push(currentToolGroup);
                  elements.messages.appendChild(createToolGroupNode(currentToolGroup));
                } else {
                  currentToolGroup.tools.push(toolEntry);
                  updateToolGroupNode(currentToolGroup);
                }

                // Text after tools goes to a new segment
                currentAssistantMessage = null;

                saveSessions();
                scrollToBottom();
              }
              return true;
            }

            if (event === 'response.output_item.done') {
              // Update arguments on the tool entry if we have a tool group
              const item = payload.item;
              if (item?.type === 'function_call' && currentToolGroup) {
                const callId = item.call_id || item.id;
                const entry = callId
                  ? currentToolGroup.tools.find(t => t.id === callId)
                  : currentToolGroup.tools.find(t => t.name === String(item.name || '') && t.status === 'running');
                if (entry) {
                  entry.arguments = String(item.arguments || entry.arguments || '');
                }
                updateToolGroupNode(currentToolGroup);
                saveSessions();
              }
              return true;
            }

            if (event === 'response.tool_exec.end') {
              if (currentToolGroup) {
                const callId = payload.call_id;
                const entry = currentToolGroup.tools.find(t => t.id === callId);
                if (entry) {
                  entry.status = 'done';
                  updateToolGroupNode(currentToolGroup);
                }
                // Check if all tools in group are done
                if (currentToolGroup.tools.every(t => t.status === 'done')) {
                  currentToolGroup.status = 'done';
                  updateToolGroupNode(currentToolGroup);
                }
              }
              // Handle images
              if (payload.images && payload.images.length > 0) {
                const msg = ensureAssistantMessage();
                payload.images.forEach(url => {
                  msg.content += `\n\n![Generated Image](${url})\n`;
                });
                updateAssistantNode(msg);
              }
              saveSessions();
              scrollToBottom();
              return true;
            }

            if (event === 'response.completed') {
              const usage = payload?.response?.usage;
              closeToolGroup();
              markToolGroupsDone(session);
              // Apply usage to the last assistant message
              const lastAssistant = [...session.messages].reverse().find(m => m.role === 'assistant');
              if (lastAssistant) {
                if (usage) lastAssistant.usage = usage;
                updateAssistantNode(lastAssistant);
              }
              saveSessions();
              scrollToBottom();
              return true;
            }

            if (event === 'response.failed') {
              const errorMessage = payload?.error?.message || 'The response failed.';
              addErrorMessage(errorMessage, session);
              closeToolGroup();
              markToolGroupsDone(session);
              const lastAssistant = [...session.messages].reverse().find(m => m.role === 'assistant');
              if (lastAssistant) updateAssistantNode(lastAssistant);
              saveSessions();
              scrollToBottom(true);
              return true;
            }

            return true;
          });

          closeToolGroup();
          markToolGroupsDone(session);
          const lastAssistant = [...session.messages].reverse().find(m => m.role === 'assistant');
          if (lastAssistant) updateAssistantNode(lastAssistant);
          persistAndRefreshShell();
          scrollToBottom();
        } catch (err) {
          closeToolGroup();
          markToolGroupsDone(session);
          const lastAssistant = [...session.messages].reverse().find(m => m.role === 'assistant');
          if (lastAssistant) updateAssistantNode(lastAssistant);

          if (err?.name === 'AbortError') {
            persistAndRefreshShell();
            return;
          }

          const message = err?.message || 'Network error. Please try again.';
          addErrorMessage(message, session);
          if (err?.status === 401) {
            handleAuthFailure();
          }

          persistAndRefreshShell();
          scrollToBottom(true);
        } finally {
          state.abortController = null;
          setStreaming(false);
          refreshRelativeTimes();
        }
      };

      // ===== Server session helpers =====
      const convertServerMessages = (serverMessages) => {
        const result = [];
        let currentGroup = null;

        const flushGroup = () => {
          if (currentGroup) {
            result.push(currentGroup);
            currentGroup = null;
          }
        };

        for (const msg of serverMessages) {
          const parts = Array.isArray(msg.parts) ? msg.parts : [];
          const created = msg.created_at || Date.now();

          // Walk through parts in order to preserve interleaving
          for (const part of parts) {
            if (part.type === 'text' && part.text) {
              flushGroup();
              result.push({
                id: generateId('msg'),
                role: msg.role === 'user' ? 'user' : 'assistant',
                content: part.text,
                created
              });
            } else if (part.type === 'tool_call') {
              const toolEntry = {
                id: part.tool_call_id || generateId('tool'),
                name: part.tool_name || 'tool',
                arguments: part.tool_arguments || '',
                status: 'done',
                created
              };
              if (!currentGroup) {
                currentGroup = {
                  id: generateId('msg'),
                  role: 'tool-group',
                  tools: [toolEntry],
                  expanded: false,
                  status: 'done',
                  created
                };
              } else {
                currentGroup.tools.push(toolEntry);
              }
            }
            // tool_result parts are context for the LLM, skip in UI
          }

          // If message had no recognized parts, emit text content if present
          if (parts.length === 0 && (msg.role === 'user' || msg.role === 'assistant')) {
            flushGroup();
            result.push({
              id: generateId('msg'),
              role: msg.role,
              content: '',
              created
            });
          }
        }

        flushGroup();
        return result;
      };

      const loadServerSessionMessages = async (sessionId) => {
        try {
          const headers = {};
          if (state.token) headers.Authorization = `Bearer ${state.token}`;
          const resp = await fetch(`/v1/sessions/${sessionId}/messages`, { headers });
          if (!resp.ok) return null;
          const data = await resp.json();
          if (!Array.isArray(data.messages)) return null;
          return convertServerMessages(data.messages);
        } catch {
          return null;
        }
      };

      const mergeServerSessions = async () => {
        try {
          const headers = {};
          if (state.token) headers.Authorization = `Bearer ${state.token}`;
          const resp = await fetch('/v1/sessions', { headers });
          if (!resp.ok) return;
          const data = await resp.json();
          if (!Array.isArray(data.sessions)) return;

          const localIds = new Set(state.sessions.map(s => s.id));

          for (const serverSession of data.sessions) {
            if (localIds.has(serverSession.id)) continue;
            // Also check if session ID appears with the sess_ prefix convention
            const prefixedId = `sess_${serverSession.id}`;
            if (localIds.has(prefixedId)) continue;

            state.sessions.push({
              id: serverSession.id,
              title: serverSession.summary || 'New chat',
              created: serverSession.created_at || Date.now(),
              messages: [],
              messageCount: serverSession.message_count || 0,
              _serverOnly: true
            });
          }

          saveSessions();
          renderSidebar();
        } catch {
          // Gracefully fall back to localStorage-only
        }
      };

      // ===== Initialization =====
      const initialize = async () => {
        state.sessions = loadSessions();

        // Check URL for a specific session ID
        const urlSessionId = sessionIdFromURL();
        if (urlSessionId) {
          const found = state.sessions.find(s => s.id === urlSessionId);
          if (found) {
            state.activeSessionId = found.id;
          } else {
            // Create a server-only stub that will be lazy-loaded
            const stub = {
              id: urlSessionId,
              title: 'Loadingâ€¦',
              created: Date.now(),
              messages: [],
              _serverOnly: true
            };
            state.sessions.unshift(stub);
            state.activeSessionId = urlSessionId;
          }
        }

        ensureActiveSession();

        renderSidebar();
        renderMessages(true);
        renderModelOptions();
        autoGrowPrompt();

        if (!state.token) {
          setConnectionState('Token required', 'bad');
          openAuthModal('', true);
        } else {
          try {
            setConnectionState('Validating tokenâ€¦');
            state.models = await fetchModels();
            renderModelOptions();
            setConnectionState('', '');

            // Merge server-side sessions after successful auth
            await mergeServerSessions();

            // Lazy-load messages for URL-targeted server session
            const active = getActiveSession();
            if (active && active._serverOnly) {
              const msgs = await loadServerSessionMessages(active.id);
              if (msgs !== null) {
                active.messages = msgs;
                if (msgs.length > 0) {
                  const firstUserMsg = msgs.find(m => m.role === 'user');
                  if (firstUserMsg) active.title = truncate(firstUserMsg.content, 60);
                }
                delete active._serverOnly;
                saveSessions();
                renderSidebar();
                renderMessages(true);
              }
            }
          } catch (err) {
            const message = err?.message || 'Unable to validate token.';
            setConnectionState(message, 'bad');
            if (err?.status === 401) {
              handleAuthFailure();
            }
          }
        }
      };

      // ===== Event listeners =====
      elements.newChatBtn.addEventListener('click', () => {
        if (state.streaming) return;

        const session = createSession();
        state.sessions.unshift(session);
        state.activeSessionId = session.id;
        updateURL(session.id);
        persistAndRefreshShell();
        renderMessages(true);
        elements.promptInput.focus();
        closeSidebarIfMobile();
      });

      elements.settingsBtn.addEventListener('click', () => {
        openAuthModal('', false);
      });

      elements.mobileMenuBtn.addEventListener('click', openSidebar);
      elements.sidebarBackdrop.addEventListener('click', closeSidebar);
      elements.sidebarCloseBtn.addEventListener('click', closeSidebar);

      elements.modelSelect.addEventListener('change', () => {
        state.selectedModel = elements.modelSelect.value;
        if (state.selectedModel) {
          localStorage.setItem(STORAGE_KEYS.selectedModel, state.selectedModel);
        } else {
          localStorage.removeItem(STORAGE_KEYS.selectedModel);
        }
      });

      elements.chatScroll.addEventListener('scroll', () => {
        state.autoScroll = isNearBottom();
      });

      elements.promptInput.addEventListener('input', autoGrowPrompt);
      elements.promptInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey && !event.isComposing) {
          event.preventDefault();
          sendMessage();
        }
      });

      elements.sendBtn.addEventListener('click', sendMessage);
      elements.stopBtn.addEventListener('click', () => {
        if (state.abortController) {
          state.abortController.abort();
        }
      });

      // File attachment handlers
      elements.attachBtn.addEventListener('click', () => {
        elements.fileInput.click();
      });
      elements.fileInput.addEventListener('change', () => {
        if (elements.fileInput.files.length > 0) {
          handleFiles(elements.fileInput.files);
          elements.fileInput.value = '';
        }
      });

      // Drag and drop
      let dragCounter = 0;
      const mainEl = document.querySelector('.main');
      mainEl.addEventListener('dragenter', (e) => {
        e.preventDefault();
        dragCounter++;
        elements.dropOverlay.classList.remove('hidden');
      });
      mainEl.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dragCounter--;
        if (dragCounter <= 0) {
          dragCounter = 0;
          elements.dropOverlay.classList.add('hidden');
        }
      });
      mainEl.addEventListener('dragover', (e) => {
        e.preventDefault();
      });
      mainEl.addEventListener('drop', (e) => {
        e.preventDefault();
        dragCounter = 0;
        elements.dropOverlay.classList.add('hidden');
        if (e.dataTransfer.files.length > 0) {
          handleFiles(e.dataTransfer.files);
        }
      });

      // Paste support
      elements.promptInput.addEventListener('paste', (e) => {
        const files = [];
        if (e.clipboardData && e.clipboardData.items) {
          for (const item of e.clipboardData.items) {
            if (item.kind === 'file') {
              const file = item.getAsFile();
              if (file) files.push(file);
            }
          }
        }
        if (files.length > 0) {
          handleFiles(files);
        }
      });

      elements.authConnectBtn.addEventListener('click', connectToken);
      elements.authCancelBtn.addEventListener('click', closeAuthModal);
      elements.authTokenInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          connectToken();
        }
      });

      window.addEventListener('resize', () => {
        if (!window.matchMedia('(max-width: 767px)').matches) {
          closeSidebar();
        }
      });

      window.addEventListener('popstate', async () => {
        const urlId = sessionIdFromURL();
        if (!urlId || urlId === state.activeSessionId) return;

        const found = state.sessions.find(s => s.id === urlId);
        if (found) {
          state.activeSessionId = found.id;
          if (found._serverOnly) {
            const msgs = await loadServerSessionMessages(found.id);
            if (msgs !== null) {
              found.messages = msgs;
              delete found._serverOnly;
            }
          }
          persistAndRefreshShell();
          renderMessages(true);
        }
      });

      setInterval(refreshRelativeTimes, 60_000);

      initialize();
    })();
  </script>
</body>
</html>
